\documentclass[12pt]{article}
%\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{asymptote}
\usepackage{calc}
%\usepackage{caption}
%\usepackage{chemfig}
\usepackage{color}
\usepackage{commath}
%\usepackage{enumitem}
%\usepackage[c]{esvect}
%\usepackage{etoolbox}
\usepackage{fancyhdr}
%\usepackage{float}
%\usepackage{fontspec}    %fontspec only works with xetex and luatex.
%\usepackage{fp}
\usepackage{geometry}
%\usepackage{graphicx}
\usepackage{lastpage}
%\usepackage{listings}
%\usepackage{luacode}
%\usepackage{makeidx}
\usepackage{mathtools}
%\usepackage{mhchem}
%\usepackage{pgfplots}
%\usepackage{setspace}
%\usepackage{siunitx}
%\usepackage{tcolorbox}
%\usepackage{tikz}
\usepackage{todonotes}
%\usepackage{pgfmath}
\usepackage{biblatex}

\addbibresource{refs.bib}

%\setmainfont{DejaVu Sans}    %This is part of the fontspec package.
%\doublespacing

% This very important is you don't want code colored in grey scale
%\lstset{
%    basicstyle=\ttfamily, % This is equivalent to monospace
%    numbers=left,
%    numberstyle=\color{magenta},
%    keywordstyle=\color{blue},
%    stringstyle=\color{red},
%    commentstyle=\color{green}\textit
%}

% For multipage align*
\allowdisplaybreaks


\newcommand{\keyword}[1]{\textbf{#1}\index{#1}}
\newcommand{\keywordidx}[2]{\textbf{#1}\index{#2}}

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\avg}[1]{\overline{#1}}
\newcommand{\sd}[1]{\text{SD}\del{#1}}
\newcommand{\var}[1]{\text{Var}\del{#1}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}

\newcommand{\lf}{\backslash}

\newcommand{\beq}{::=}
\newcommand{\bs}[1]{\mathrm{#1}}
\newcommand{\bstr}[1]{\mathrm{"#1"}}

\newcommand{\newtyvar}{\mathrm{newtyvar}}
\newcommand{\inst}[1]{\mathrm{inst}\del{#1}}
\newcommand{\gen}[2]{\mathrm{gen}\del{#1, #2}}
\newcommand{\freevars}[1]{\mathrm{freevars}\del{#1}}
\newcommand{\unify}[2]{\mathrm{unify}\del{#1, #2}}

\newcommand{\env}[1]{\langle #1 \rangle}


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}


\title{THM: A Hindley-Milner Typed Language}
\author{Taran Lynn}

\begin{document}
\maketitle


\section{Introduction}

In this paper I will cover the design and implementation of the THM
programming language.
THM is a minimalist Hindley-Milner typed\todo{cite}
programming language with algebraic data types\todo{cite}.
The goal of designing THM was to create a language and implementation
that was simple enough that it could be used as a teaching tool for
courses on type inference.
To this end the it has a small specification (see the appendix) and a
small implementation (less than 1,000 lines of Haskell).

THM is loosely base on the ML family of languages, specifically
Standard ML.
Besides dropping support for modules, other major changes were made to
the syntax and semantics to reduce the size of the specification and
implementation.
For example, unlike most MLs, THM is lazily evaluated.
This is relatively trivial to implement, and avoids the need to
implement other control structures.
Another major change is that there is no \verb~case~ construct.
Instead there is a \verb~case~ \textbf{function}, which acts as the
elimination rule for a type.

The THM interpreter is implemented in Haskell.
To use it the user simply gives it a list of files with type and
function definitions to type check and load, and the interpreter drops
the user into a read/eval/print loop (REPL) that process THM
expressions.
An example of one definition file is
\begin{verbatim}
type Nat [ Z S(Nat) ]
fix natInd x f = case[Nat] x (\p. f (natInd x f p));

pred = case[Nat] Z (\p. p);
fix add m n = case[Nat] n (\p. S (add p n)) m;
fix mult m n = case[Nat] Z (\p. add n (mult p n)) m;
\end{verbatim}
, and a corresponding REPL session is
\begin{verbatim}
\> Z
Z : Nat
\> S
S : Nat -> Nat
\> mult (S (S Z)) (S (S (S Z)))
S (S (S (S (S (S Z))))) : Nat
\>
\end{verbatim}

The following sections of the paper will give an intutionistic
description of the background, design, and implementation of THM\todo{Give a brief description of sections}.
For a more formal description, please see the appendix.


\section{Background and Related Work}

\todo[inline]{Describe Hindley and Milners work}

\todo[inline]{Describe the theory behind unification}

\todo[inline]{Describe the theory behind ADTs}

\todo[inline]{Describe the creation of ML and SML}

\todo[inline]{Describe current academic work and relation to
  Haskell/Rust/etc.}


\section{Design and Implementation}

\subsection{Base Language}

At the heart of THM is the lambda calculus.
expression (denoted by $e$) are formed from variables $v$,
lambda expressions $\lf v. e$, and application $e_1~e_2$.
Note that $\lf$ is used because of its resemblance to $\lambda$.
Lambda expressions group right, while applications group left.
For example, $\lf f. \lf g. \lf x. f~g~x$ is equivalent to
$\lf f. (\lf g. (\lf x. ((f~g)~x)))$.
THM performs lazy evaluation, meaning that in an application
$e_1~e_2$, $e_1$ is first evaluated to a lambda expression
$\lf v. e_3$, and then $e_2$ is substituted into $e_3$ for $v$.
The usual shadowing rules also apply (section \ref{sec:dynamic_sem}
gives a more formal description).

On top of the base lambda calculus we add let bindings.
Syntactically these are given as
$\mathrm{let} v = e_1; \mathrm{in} e_2$.
In terms of evaluation semantics this construct is equivalent to
$(\lf v. e_1)~e_2$.
In the next section the type checking of let expressions will be
addressed, in which they have no equivalent to lambda expressions.
Finally, a fixed-point operator is added to the language to allow for
type checkable recursion.
The fixed-point operator is defined as
$\mathrm{fix}~f = f~(\mathrm{fix}~f)$.
Combined with lazy evaluation, this allows for the definition of
recursive functions.
Additionally, some syntactic sugar is also added to the base language
(see section \ref{sec:concrete_syntax}).


\subsection{Type Inference}


\subsection{Algebraic Data Types}

\subsection{Implementation Details}


\section{Conclusion}


\printbibliography


\pagebreak


\appendix

\section{Syntax}
\label{app:syntax}

\subsection{Abstract Syntax}

$x$ indicates a variable, $e$ is an expression, $C$ is a data
constructor, $\tau$ indicates a type variable, $t$ is a type, $T$ is a
type constructor, and $\alpha$ is a quantified type variable.

\begin{align}
  \mathrm{TypeDef} &:= \mathrm{type}~T~\tau_1~\cdots~\tau_m \sbr{
                     C_1\del{t_{11},\ldots,t_{1n_1}} 
                     \cdots
                     C_k\del{t_{k1},\ldots,t_{kn_k}}
                     } \label{eq:typedef}
\end{align}

\begin{align}
  t &:= t_1 \to t_2 ~|~ T~t_1 \ldots t_n ~|~ \tau ~|~ \forall \alpha. t
\end{align}

\begin{align}
  e &:= \mathrm{Var} ~|~ \mathrm{Cons} ~|~ \mathrm{Lambda} ~|~ \mathrm{App} ~|~ \mathrm{Let} ~|~ \mathrm{Fix} ~|~ \mathrm{Case}\\
  \mathrm{Var} &:= x\\
  \mathrm{Cons} &:= C\\
  \mathrm{Lambda} &:= \lambda x. e ~|~ \lambda \_. e\\
  \mathrm{App} &:= e_1~e_2\\
  \mathrm{Let} &:= \mathrm{let}~x = e_1;~\mathrm{in}~e_2\\
  \mathrm{Fix} &:= \mathrm{fix}\\
  \mathrm{Case} &:= \mathrm{case}\sbr{T}
\end{align}




\subsection{EBNF Concrete Syntax}
\label{sec:concrete_syntax}

Comments begin with \#.
Symbols as any non-keyword strings that match the regex\\
\verb~[a-zA-Z][0-9a-zA-Z]*~.
A number is \verb~[0-9]+~.

\begin{align}
  \bs{tydef} &\beq \bstr{type}, \bs{symbol}, \cbr{\bs{tyvar}},
               \bstr{[}, \cbr{\bs{condef}}, \bstr{]} ;\\
  \bs{condef} &\beq \bs{symbol}, \sbr{\bstr{(}, \cbr{\bs{type}}, \bstr{)}} ;
\end{align}

\begin{align}
  \bs{type} &\beq \bs{tycon}, \sbr{\bstr{->}, \bs{type}} ;\\
  \bs{tycon} &\beq \bs{tyatom} ~|~ \bs{symbol}, \cbr{\bs{tyatom}} ;\\
  \bs{typatom} &\beq \bs{tyvar} ~|~ \bstr{(}, \bs{type}, \bstr{)} ;\\
  \bs{tyvar} &\beq \bstr{'}, \bs{symbol} ;
\end{align}

\begin{align}
  \bs{funcdef} &\beq \sbr{\bstr{fix}}, \bs{symbol}, \cbr{\bs{symbol}}, \bstr{=}, \bs{expr}, \bstr{;} ;\\
  \bs{expr} &\beq \bstr{let}, \bs{funcdef}, \cbr{\bs{funcdef}}, \bstr{in}, \bs{expr} ;\\
              &\qquad|~ \bstr{\backslash}, \bs{arg}, \cbr{\bs{arg}}, \bstr{.}, \bs{expr} ;\\
                 &\qquad|~ \bs{app}\\
  \bs{app} &\beq \bs{atom} ~|~ \bs{app}, \bs{atom} ;\\
  \bs{atom} &\beq \bstr{(}, \bs{expr}, \bstr{)} ~|~ \bs{symbol} ~|~ \bs{case} ;\\
  \bs{arg} &\beq \bs{symbol} ~|~ \bstr{\_}\\
  \bs{case} &\beq \bstr{case}, \bstr{[}, \bs{symbol}, \bstr{]} ;
\end{align}

Note that the EBNF above has some syntatic sugar to make programming
easier.
The rules to convert from the main language to the abstract one are
\begin{align}
  \lambda x_1 x_2 \cdots. e
  &\Rightarrow \lambda x_1. \lambda x_2. \lambda \cdots. e\\
  \mathrm{let}~x_1 := e_1;~x_2 := e_2;~\ldots~\mathrm{in}~e
  &\Rightarrow \mathrm{let}~x_1 := e_1;~\mathrm{in}~\mathrm{let}~x_2 := e_2;~\mathrm{in}~\ldots~\mathrm{in}~e\\
  \mathrm{let}~f~x_1~x_2~\cdots := e_1;~\mathrm{in}~e_2
  &\Rightarrow \mathrm{let}~f := \lambda x_1 x_2 \cdots. e_1;~\mathrm{in}~e_2\\
  \mathrm{let}~\mathrm{fix}~f~x_1~x_2~\cdots := e_1;~\mathrm{in}~e_2
  &\Rightarrow \mathrm{let}~f := \mathrm{fix}~\del{\lambda f x_1 x_2 \cdots. e_1};~\mathrm{in}~e_2
\end{align}


\section{Semantics}
\label{app:semantics}


\subsection{Type Definitions}
\label{sec:type_defs}

Suppose we have a type definition following the pattern given in
\eqref{eq:typedef}.
There are three semantic rules that need to be verified.
\begin{enumerate}
\item For any pair of type variables
  $a, b \in \cbr{\tau_1,\ldots,\tau_m}$ that $T$ parameterizes over
  $a \neq b$.

\item For any type $t$ used in one of the constructors
  $C_1,\ldots,C_k$ we require
  $\freevars{t} \subseteq \cbr{\tau_1,\ldots,\tau_m}$.

\item For any type $t$ used in one of the constructors
  $C_1,\ldots,C_k$ we require that the only type constructors used are
  $T$ and previously defined type constructors.
\end{enumerate}


\subsection{Static}
\label{sec:static_semantics}

The following is largely adapted from a description of algorithm W
from Wikipedia\cite{wikiAlgW}.
Notable typing rules that extend those from Wikipedia are those for
recursive let bindings and matches.

$\newtyvar$ creates a unique type variable.
$\unify{t_1}{t_2}$ denotes the unification substitution of $t_1$ and
$t_2$.
It does by adding $t_1 = t_2$ to the set of unification equations and
then simplifying.
$\inst{\sigma}$ takes a possibly quantified type (i.e. of the form
$\sigma = \forall \alpha_1, \ldots, \alpha_n. t$) and produces the
$t_u$ by replacing the
quantified type variables with new unique ones, that is
\begin{align*}
  t_1,\ldots,t_n &= \newtyvar\\
  t_u &= [t_1/\alpha_1, \ldots, t_n/\alpha_n] t
\end{align*}
$\gen{\Gamma}{t}$ does the opposite of $\inst{\sigma}$, that is it
quantifies over all the free type variables in $t$ that not also free
in $\Gamma$, or
\begin{align*}
  \cbr{\alpha_1, \ldots, \alpha_n} &= \freevars{t} - \freevars{\Gamma}\\
  \gen{\Gamma}{t} &= \forall \alpha_1~\ldots~\alpha_n, t
\end{align*}
The syntax $\Gamma \vdash e : t$ means that in the context
$\Gamma$, $e$ has type $t$.


\begin{description}
\item[Var]
  \begin{equation}
    \frac{x : \sigma \in \Gamma \qquad t = \inst{\sigma}}{\Gamma \vdash x : t}
  \end{equation}

\item[Cons] Suppose $C(t_1,\ldots,t_n)$ is a constructor for some type
  $T~\tau_1\cdots\tau_m$, then
  \begin{equation}
    \frac{}{\Gamma \vdash C : \forall \tau_1\cdots\tau_m, t_1 \to \cdots \to t_n \to T~\tau_1\cdots\tau_m}
  \end{equation}

\item[Lambda]
  \begin{gather}
    \frac{\tau = \newtyvar \qquad \Gamma, x : \tau \vdash e : t}{\Gamma \vdash \lambda x. e : \tau \to t}\\
    \frac{\tau = \newtyvar \qquad \Gamma \vdash e : t}{\Gamma \vdash \lambda \_. e : \tau \to t}
  \end{gather}

\item[App]
  \begin{equation}
    \frac{\Gamma \vdash e_1 : t_1 \qquad \Gamma \vdash e_2 : t_2 \qquad \tau = \newtyvar \qquad \unify{t_1}{t_2 \to \tau}}{\Gamma \vdash e_1~e_2 : \tau}
  \end{equation}

\item[Let]
  \begin{equation}
    \frac{\Gamma \vdash e_1 : t \qquad \Gamma, x : \gen{\Gamma}{t} \vdash e_2 : t'}{\Gamma \vdash \mathrm{let}~x = e_1;~\mathrm{in}~e_2 : t'}
  \end{equation}

\item[Fix]
  \begin{equation}
    \frac{t_1, t_2 = \newtyvar}{\Gamma \vdash \mathrm{fix} : (t_1 \to t_2) \to (t_1 \to t_2)}
  \end{equation}

\item[Case] Suppose we have a type definition following the pattern
  given in \eqref{eq:typedef}.
  \begin{equation}
    \frac{\rho = \newtyvar}{\Gamma \vdash \mathrm{case}\sbr{T} : T~\tau_1\cdots\tau_m \to (t_{11} \to \cdots \to t_{1n_1} \to \rho) \to \cdots \to (t_{k1} \to \cdots \to t_{kn_k} \to \rho) \to \rho}
  \end{equation}
\end{description}


\subsection{Dynamic}
\label{sec:dynamic_sem}

Let $\sigma$ be the context of variable bindings and their
environments.
$\sigma$ thus has the type
$$\Sigma = X \to E \times \Sigma$$, where $X$ is the
set of all variables, and $E$ is the set of all expressions.
The notation $\sigma' = [(e, s)/x]\sigma$ means
$$\sigma'(y) =
\begin{cases}
  (e, s) &\text{if } y = x\\
  \sigma(y) &\text{if } y \neq x\\
\end{cases}$$

\begin{description}
\item[Var]
  \begin{equation}
\frac{\sigma(x) = (e, s)}{\env{x, \sigma} \to \env{e, s}}
\end{equation}

\item[Lambda] Lambda expressions are fully reduced.

\item[App] 
  \begin{gather}
    \frac{\env{e_1, \sigma} \to \env{e_1', \sigma}}{\env{e_1~e_2, \sigma} \to \env{e_1'~e_2, \sigma}}\\
    \frac{}{\env{(\lambda x. e_1)~e_2, \sigma} \to \env{e_1, [(e_2, \sigma)/x]\sigma}}\\
    \frac{}{\env{(\lambda \_. e_1)~e_2, \sigma} \to \env{e_1, \sigma}}
  \end{gather}

\item[Let]
  \begin{gather}
    \frac{\env{e_1, \sigma} \to \env{e_1', \sigma}}{\env{\mathrm{let}~x = e_1;~\mathrm{in}~e_2, \sigma} \to \env{\mathrm{let}~x = e_1';~\mathrm{in}~e_2, \sigma}}\\
    \frac{}{\env{\mathrm{let}~x = e_1;~\mathrm{in}~e_2, \sigma} \to \env{e_2, [(e_1, \sigma)/x]\sigma}}
  \end{gather}

\item[Fix]
  \begin{equation}
    \frac{}{\env{\mathrm{fix}~f, \sigma} \to \env{f~(\mathrm{fix}~f), \sigma}}
  \end{equation}

\item[natCase] Suppose we have a type definition following the pattern
  given in \eqref{eq:typedef}.
  Let $C_i$ be the $i$th listed constructor, then
  \begin{gather}
    \frac{}{\env{\mathrm{case}~(C_i~x_1~\cdots~x_n)~f_1~\cdots~f_k, \sigma} \to \env{f_i~x_1~\cdots~x_n, \sigma}}\\
  \end{gather}
\end{description}


\end{document}
