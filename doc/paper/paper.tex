\documentclass[12pt]{article}
%\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{asymptote}
\usepackage{calc}
%\usepackage{caption}
%\usepackage{chemfig}
\usepackage{color}
\usepackage{commath}
%\usepackage{enumitem}
%\usepackage[c]{esvect}
%\usepackage{etoolbox}
\usepackage{fancyhdr}
%\usepackage{float}
%\usepackage{fontspec}    %fontspec only works with xetex and luatex.
%\usepackage{fp}
\usepackage{geometry}
%\usepackage{graphicx}
\usepackage{lastpage}
%\usepackage{listings}
%\usepackage{luacode}
%\usepackage{makeidx}
\usepackage{mathtools}
%\usepackage{mhchem}
%\usepackage{pgfplots}
%\usepackage{setspace}
%\usepackage{siunitx}
%\usepackage{tcolorbox}
%\usepackage{tikz}
%\usepackage{todonotes}
%\usepackage{pgfmath}
\usepackage{biblatex}

\addbibresource{refs.bib}

\geometry{hmargin=2cm,vmargin=4cm}
%\setmainfont{DejaVu Sans}    %This is part of the fontspec package.
%\doublespacing

% This very important is you don't want code colored in grey scale
%\lstset{
%    basicstyle=\ttfamily, % This is equivalent to monospace
%    numbers=left,
%    numberstyle=\color{magenta},
%    keywordstyle=\color{blue},
%    stringstyle=\color{red},
%    commentstyle=\color{green}\textit
%}

% For multipage align*
\allowdisplaybreaks


\newcommand{\keyword}[1]{\textbf{#1}\index{#1}}
\newcommand{\keywordidx}[2]{\textbf{#1}\index{#2}}

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\avg}[1]{\overline{#1}}
\newcommand{\sd}[1]{\text{SD}\del{#1}}
\newcommand{\var}[1]{\text{Var}\del{#1}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}

\newcommand{\beq}{::=}
\newcommand{\bs}[1]{\mathrm{#1}}
\newcommand{\bstr}[1]{\mathrm{"#1"}}

\newcommand{\newtyvar}{\mathrm{newtyvar}}
\newcommand{\inst}[1]{\mathrm{inst}\del{#1}}
\newcommand{\gen}[2]{\mathrm{gen}\del{#1, #2}}
\newcommand{\freevars}[1]{\mathrm{freevars}\del{#1}}
\newcommand{\unify}[2]{\mathrm{unify}\del{#1, #2}}

\newcommand{\env}[1]{\langle #1 \rangle}


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}


\title{A Hindley-Milner Typed Language}
\author{Taran Lynn}

\begin{document}
\maketitle


\section{Introduction}

For my project I plan to implement a language that is Hindley-Milner
typed.
An example program is given in section \ref{sec:example}.
I will design an interpreter than will read files and load function
definitions from them.
Interaction will then be done through a REPL, where the user can query
the types of and evaluate expressions.
The language will also be eagerly evaluated (call-by-value).
To make the language Turing complete it will include the unit type,
natural numbers, and a fixed point operator.
The natural numbers will be encoded as Peano numbers, with a successor
function $S$.
Additionally, a special function natCase will allow for case analysis
on the numbers, which in addition to the fixed point operator will
allow all arithmetic operations to be performed.
Because the language is eagerly evaluated, the fixed point operator
will be defined as
$$\mathrm{fix} f x = f~(\mathrm{fix}~f)~x$$
(this avoids the problem of all recursive expressions becoming
bottom).

Note that this work is an extension of my previous work on programming
languages, which include work on the calculus of constructions and
unification\cite{ttyped,tplpl}.
This language I propose implementing is essentially an ML stripped
down to its most basic components as a Hindley-Milner typed language.
As such my main references are the Standard ML
specification\cite{Milner1997TheDO} as well as Martelli and
Montanari's work on unification\cite{Martelli1982AnEU}.

While I am familiar with implementing types systems, my main learning
objective for this project are to learn how to implement type
inference, as my previous projects simply used types given by the
programmer.
Not only will this serve to help my learn about type inference, it
could potentially also help other student learn as well.
I believe the simple language and (hopefully) small implementation
will be more approachable to someone who wants to delve into the
actual workings behind type inference.

The planned tasks for implementing the language are as follows.
\begin{enumerate}
\item Implement parser [COMPLETE].

\item Implement type unifier [IN PROGRESS].

\item Implement type inference algorithm.

\item Implement execution engine.
\end{enumerate}
I expect the unification algorithm to be the most challenging to
implement, with the inference algorithm being a bit easier.
The execution engine should be straight forward to implement.
In addition to the actual interpreter, I will also submit a report
detailing the implementation and formal semantics of the language.
The development of this report will be concurrent with that of the
interpreter.
Currently preliminary work on defining the syntax and semantics of the
language are given in appendices \ref{app:syntax} and
\ref{app:semantics}, and will be included in the report.


\section{Example of Language Syntax}
\label{sec:example}

\begin{verbatim}
type Nat [ Z S(Nat) ]
fix natInd x f = case[Nat] x (\p. f (natInd x f p));

pred = case[Nat] Z (\p. p);
fix add m n = case[Nat] n (\p. S (add p n)) m;
fix mult m n = case[Nat] Z (\p. add n (mult p n)) m;
\end{verbatim}


\printbibliography


\pagebreak


\section{Syntax}
\label{app:syntax}

\subsection{Abstract Syntax}

$x$ indicates a variable, $e$ is an expression, $C$ is a data
constructor, $\tau$ indicates a type variable, $t$ is a type, $T$ is a
type constructor, and $\alpha$ is a quantified type variable.

\begin{align}
  \mathrm{TypeDef} &:= \mathrm{type}~T~\tau_1~\cdots~\tau_m \sbr{
                     C_1\del{t_{11},\ldots,t_{1n_1}} 
                     \cdots
                     C_k\del{t_{k1},\ldots,t_{kn_k}}
                     } \label{eq:typedef}
\end{align}

\begin{align}
  t &:= t_1 \to t_2 ~|~ T~t_1 \ldots t_n ~|~ \tau ~|~ \forall \alpha. t
\end{align}

\begin{align}
  e &:= \mathrm{Var} ~|~ \mathrm{Cons} ~|~ \mathrm{Lambda} ~|~ \mathrm{App} ~|~ \mathrm{Let} ~|~ \mathrm{Fix} ~|~ \mathrm{Case}\\
  \mathrm{Var} &:= x\\
  \mathrm{Cons} &:= C\\
  \mathrm{Lambda} &:= \lambda x. e ~|~ \lambda \_. e\\
  \mathrm{App} &:= e_1~e_2\\
  \mathrm{Let} &:= \mathrm{let}~x = e_1;~\mathrm{in}~e_2\\
  \mathrm{Fix} &:= \mathrm{fix}\\
  \mathrm{Case} &:= \mathrm{case}\sbr{T}
\end{align}




\subsection{EBNF Concrete Syntax}

Comments begin with \#.
Symbols as any non-keyword strings that match the regex\\
\verb~[a-zA-Z][0-9a-zA-Z]*~.
A number is \verb~[0-9]+~.

\begin{align}
  \bs{tydef} &\beq \bstr{type}, \bs{symbol}, \cbr{\bs{tyvar}},
               \bstr{[}, \cbr{\bs{condef}}, \bstr{]} ;\\
  \bs{condef} &\beq \bs{symbol}, \sbr{\bstr{(}, \cbr{\bs{type}}, \bstr{)}} ;
\end{align}

\begin{align}
  \bs{type} &\beq \bs{tycon}, \sbr{\bstr{->}, \bs{type}} ;\\
  \bs{tycon} &\beq \bs{tyatom} ~|~ \bs{symbol}, \cbr{\bs{tyatom}} ;\\
  \bs{typatom} &\beq \bs{tyvar} ~|~ \bstr{(}, \bs{type}, \bstr{)} ;\\
  \bs{tyvar} &\beq \bstr{'}, \bs{symbol} ;
\end{align}

\begin{align}
  \bs{funcdef} &\beq \sbr{\bstr{fix}}, \bs{symbol}, \cbr{\bs{symbol}}, \bstr{=}, \bs{expr}, \bstr{;} ;\\
  \bs{expr} &\beq \bstr{let}, \bs{funcdef}, \cbr{\bs{funcdef}}, \bstr{in}, \bs{expr} ;\\
              &\qquad|~ \bstr{\backslash}, \bs{arg}, \cbr{\bs{arg}}, \bstr{.}, \bs{expr} ;\\
                 &\qquad|~ \bs{app}\\
  \bs{app} &\beq \bs{atom} ~|~ \bs{app}, \bs{atom} ;\\
  \bs{atom} &\beq \bstr{(}, \bs{expr}, \bstr{)} ~|~ \bs{symbol} ~|~ \bs{case} ;\\
  \bs{arg} &\beq \bs{symbol} ~|~ \bstr{\_}\\
  \bs{case} &\beq \bstr{case}, \bstr{[}, \bs{symbol}, \bstr{]} ;
\end{align}

Note that the EBNF above has some syntatic sugar to make programming
easier.
The rules to convert from the main language to the abstract one are
\begin{align}
  \lambda x_1 x_2 \cdots. e
  &\Rightarrow \lambda x_1. \lambda x_2. \lambda \cdots. e\\
  \mathrm{let}~x_1 := e_1;~x_2 := e_2;~\ldots~\mathrm{in}~e
  &\Rightarrow \mathrm{let}~x_1 := e_1;~\mathrm{in}~\mathrm{let}~x_2 := e_2;~\mathrm{in}~\ldots~\mathrm{in}~e\\
  \mathrm{let}~f~x_1~x_2~\cdots := e_1;~\mathrm{in}~e_2
  &\Rightarrow \mathrm{let}~f := \lambda x_1 x_2 \cdots. e_1;~\mathrm{in}~e_2\\
  \mathrm{let}~\mathrm{fix}~f~x_1~x_2~\cdots := e_1;~\mathrm{in}~e_2
  &\Rightarrow \mathrm{let}~f := \mathrm{fix}~\del{\lambda f x_1 x_2 \cdots. e_1};~\mathrm{in}~e_2
\end{align}


\section{Semantics}
\label{app:semantics}


\subsection{Type Definitions}
\label{sec:type_defs}

Suppose we have a type definition following the pattern given in
\eqref{eq:typedef}.
There are three semantic rules that need to be verified.
\begin{enumerate}
\item For any pair of type variables
  $a, b \in \cbr{\tau_1,\ldots,\tau_m}$ that $T$ parameterizes over
  $a \neq b$.

\item For any type $t$ used in one of the constructors
  $C_1,\ldots,C_k$ we require
  $\freevars{t} \subseteq \cbr{\tau_1,\ldots,\tau_m}$.

\item For any type $t$ used in one of the constructors
  $C_1,\ldots,C_k$ we require that the only type constructors used are
  $T$ and previously defined type constructors.
\end{enumerate}


\subsection{Static}
\label{sec:static_semantics}

The following is largely adapted from a description of algorithm W
from Wikipedia\cite{wikiAlgW}.
Notable typing rules that extend those from Wikipedia are those for
recursive let bindings and matches.

$\newtyvar$ creates a unique type variable.
$\unify{t_1}{t_2}$ denotes the unification substitution of $t_1$ and
$t_2$.
It does by adding $t_1 = t_2$ to the set of unification equations and
then simplifying.
$\inst{\sigma}$ takes a possibly quantified type (i.e. of the form
$\sigma = \forall \alpha_1, \ldots, \alpha_n. t$) and produces the
$t_u$ by replacing the
quantified type variables with new unique ones, that is
\begin{align*}
  t_1,\ldots,t_n &= \newtyvar\\
  t_u &= [t_1/\alpha_1, \ldots, t_n/\alpha_n] t
\end{align*}
$\gen{\Gamma}{t}$ does the opposite of $\inst{\sigma}$, that is it
quantifies over all the free type variables in $t$ that not also free
in $\Gamma$, or
\begin{align*}
  \cbr{\alpha_1, \ldots, \alpha_n} &= \freevars{t} - \freevars{\Gamma}\\
  \gen{\Gamma}{t} &= \forall \alpha_1~\ldots~\alpha_n, t
\end{align*}
The syntax $\Gamma \vdash e : t$ means that in the context
$\Gamma$, $e$ has type $t$.


\begin{description}
\item[Var]
  \begin{equation}
    \frac{x : \sigma \in \Gamma \qquad t = \inst{\sigma}}{\Gamma \vdash x : t}
  \end{equation}

\item[Cons] Suppose $C(t_1,\ldots,t_n)$ is a constructor for some type
  $T~\tau_1\cdots\tau_m$, then
  \begin{equation}
    \frac{}{\Gamma \vdash C : \forall \tau_1\cdots\tau_m, t_1 \to \cdots \to t_n \to T~\tau_1\cdots\tau_m}
  \end{equation}

\item[Lambda]
  \begin{gather}
    \frac{\tau = \newtyvar \qquad \Gamma, x : \tau \vdash e : t}{\Gamma \vdash \lambda x. e : \tau \to t}\\
    \frac{\tau = \newtyvar \qquad \Gamma \vdash e : t}{\Gamma \vdash \lambda \_. e : \tau \to t}
  \end{gather}

\item[App]
  \begin{equation}
    \frac{\Gamma \vdash e_1 : t_1 \qquad \Gamma \vdash e_2 : t_2 \qquad \tau = \newtyvar \qquad \unify{t_1}{t_2 \to \tau}}{\Gamma \vdash e_1~e_2 : \tau}
  \end{equation}

\item[Let]
  \begin{equation}
    \frac{\Gamma \vdash e_1 : t \qquad \Gamma, x : \gen{\Gamma}{t} \vdash e_2 : t'}{\Gamma \vdash \mathrm{let}~x = e_1;~\mathrm{in}~e_2 : t'}
  \end{equation}

\item[Fix]
  \begin{equation}
    \frac{t_1, t_2 = \newtyvar}{\Gamma \vdash \mathrm{fix} : (t_1 \to t_2) \to (t_1 \to t_2)}
  \end{equation}

\item[Case] Suppose we have a type definition following the pattern
  given in \eqref{eq:typedef}.
  \begin{equation}
    \frac{\rho = \newtyvar}{\Gamma \vdash \mathrm{case}\sbr{T} : T~\tau_1\cdots\tau_m \to (t_{11} \to \cdots \to t_{1n_1} \to \rho) \to \cdots \to (t_{k1} \to \cdots \to t_{kn_k} \to \rho) \to \rho}
  \end{equation}
\end{description}


\subsection{Dynamic}

Let $\sigma$ be the context of variable bindings and their
environments.
$\sigma$ thus has the type
$$\Sigma = X \to E \times \Sigma$$, where $X$ is the
set of all variables, and $E$ is the set of all expressions.
The notation $\sigma' = [(e, s)/x]\sigma$ means
$$\sigma'(y) =
\begin{cases}
  (e, s) &\text{if } y = x\\
  \sigma(y) &\text{if } y \neq x\\
\end{cases}$$

\begin{description}
\item[Var]
  \begin{equation}
\frac{\sigma(x) = (e, s)}{\env{x, \sigma} \to \env{e, s}}
\end{equation}

\item[Lambda] Lambda expressions are fully reduced.

\item[App] 
  \begin{gather}
    \frac{\env{e_1, \sigma} \to \env{e_1', \sigma}}{\env{e_1~e_2, \sigma} \to \env{e_1'~e_2, \sigma}}\\
    \frac{}{\env{(\lambda x. e_1)~e_2, \sigma} \to \env{e_1, [(e_2, \sigma)/x]\sigma}}\\
    \frac{}{\env{(\lambda \_. e_1)~e_2, \sigma} \to \env{e_1, \sigma}}
  \end{gather}

\item[Let]
  \begin{gather}
    \frac{\env{e_1, \sigma} \to \env{e_1', \sigma}}{\env{\mathrm{let}~x = e_1;~\mathrm{in}~e_2, \sigma} \to \env{\mathrm{let}~x = e_1';~\mathrm{in}~e_2, \sigma}}\\
    \frac{}{\env{\mathrm{let}~x = e_1;~\mathrm{in}~e_2, \sigma} \to \env{e_2, [(e_1, \sigma)/x]\sigma}}
  \end{gather}

\item[Fix]
  \begin{equation}
    \frac{}{\env{\mathrm{fix}~f, \sigma} \to \env{f~(\mathrm{fix}~f), \sigma}}
  \end{equation}

\item[natCase] Suppose we have a type definition following the pattern
  given in \eqref{eq:typedef}.
  Let $C_i$ be the $i$th listed constructor, then
  \begin{gather}
    \frac{}{\env{\mathrm{case}~(C_i~x_1~\cdots~x_n)~f_1~\cdots~f_k, \sigma} \to \env{f_i~x_1~\cdots~x_n, \sigma}}\\
  \end{gather}
\end{description}


\end{document}
